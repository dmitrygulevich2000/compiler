
# 3. Recursive Descent Parser

В этом задании мы хотим научиться преобразовывать поток токенов в AST. 

Для этого воспользуемся алгоритмом парсинга _рекурсивным спуском_. 
Немотря на свою простоту, он очень гибкий и надёжный. 
Он используется компиляторами _Rust, Go, C++_ и другими.

## Пререквизиты
  
1. Lexer
2. Ast

## Рекурсивный спуск

### Идея

#### Ambigous grammar

Как бы мы хотели видеть нашу грамматику:

```ebnf
expression   ::= literal
               | unary
               | binary
               | ( <expression> )
               
unary        ::= ( "-" | "!" ) <expression>
binary       ::= <expression> <operator> <expression> ;
operator     ::= "==" | "!=" | "<" | "<=" | ">" | ">="
               | "+"  | "-"  | "*" | "/"
```

К сожалению, в таком простом виде правила никак не учитывают **приоритет
операций**: `1 + 2 * 3` — это `(1 + 2) * 3` или `1 + (2 * 3)` ? 

Таблица приоритетов операций ([полная версия](https://en.cppreference.com/w/c/language/operator_precedence)):

| Precedence |  Operator  |      Associativity      |
|-------------------------|-------------------------|-
|      1     | f() — call |           →             |
|      2     |    - !     |           ←             |
|      3     |    * /     |           →             |
|      4     |    + -     |           →             |
|      5     |    < <=    |           →             |
|            |    > >=    |                         |
|      6     |    == !=   |           →             |

#### Infinite token stream

Представьте себе бесконечный вправо корректный поток токенов в составе выражения.

В какой-то момент в этом потоке нам впервые встретится оператор с самым низким
приоритетом: `==`. Это значит, что слева от него все операции имеют **более
выскоий приоритет**. Значит их можно распарсить операцией `ParseB`, которая
работает с грамматикой только из 5 правил.

```
        Parse(...   ==   ...  ==  ...  ==  ... )
      --------------------------------------------
                    ==
       ParseB(...)   |
                     |
                   Parse(...  ==  ...  ==  ...)
```

`ParseB` будет работать абсолютно аналагично:

```
       ParseB(...   <=  ...  >=  ... )
      ----------------------------------
                    <=
       ParseC(...)   |
                     |
                   ParseB(...  >=  ...)
```

В терминах нашей грамматики правила будут называться вот так: 

| Fake Name | Real Name       |
| --------- | --------------- |
|  Parse    | ParseExpression |
|  ParseB   | ParseRelational |
|  ParseC   | ParseAdditive   |
|  ParseD   | ParseMult       |
|  ParseE   | ParseUnary      |
|  ParseF   | ParsePostfix    |
|  ParseG   | ParsePrimary    |

#### Associativity

Однако здесь есть проблема — ассоциативность. Рассмотрим пример `1 - 2 - 3`.

```
       1 - 2 - 3                                   1 - 2 - 3     ==  - 4
      -----------                             ----------------------------
         -                      !=                       -                
       1                                                   3 
           2 - 3                                   1 - 2

```

В грамматике языка мы можем решить её слудующим правилом, которое поддерживает
инвариант, что мы каждый раз отъедаем **последний** возможный оператор.

```ebnf
<additive-expression> ::= <multiplicative-expression>
                        | <additive-expression> - <multiplicative-expression>
```

Но что делать в реализации? Ведь мы не можем реализовать `ParseAdditive` c
помощью прямого вызова `ParseAdditive` на потоке символов.


#### Левая рекурсия

Правила такого вида называются леворекурсивными. 
Их парсинг реализуется превращением рекурсии в итерацию. 

```ebnf
<additive-expression> ::= <multiplicative-expression> ( - <multiplicative-expression> )* ;
```

Заметим, что здесь мы снова **потеряли ассоциативность** в грамматике. 
См. как это исправить в главе книги.

### Railroad diagrams

До изобретения eBNF синтаксис изображался вот в такой весёлой форме. Такие
картинки называются _диаграммами железнодорожный путей_.

![Pascal railroad diagram](./media/4-railroad.png)

## Задание

1. Прочитайте [Crafting Interpreters: Parsing Expressions](https://craftinginterpreters.com/parsing-expressions.html)
2. Создайте класс `Parser`, обрабатывающий все конструкции нашей 
   [грамматики](https://github.com/otakubeam/compilers-tasks/blob/master/tasks/2-ast-visitors.md#appendix-a-grammar)
4. С помощью `catch2` **напишите тесты** для парсера
   
   В реализации слудующих этапов компилятора это позволит нам быть 
   уверенными в реализации парсера.

## Playground

1. Воспользуйтесь `PrintVisitor` из прошлого задания: правильно ли парсятся выражения?
2. Создайте класс-**калькулятор арифметических выражений**
   - В первом приближении в качестве *таблицы символов* используйте `std::unordered_map`
   - Динамически обрабатывайте неопределённые случаи 

     1. `1 + true` 
     2. `if "abc" then 123`
     3. `if true then 123 else true`

   - Если хотите поддерживать функции уже сейчас, то придумайте, как в каждой
     области видимости поддеживать своё состояние таблицы символов

     Понятие _области видимости_ определите интуитивно


## Реализация

Для представления значений в калькуляторе можете воспользоваться
`std::variant<std::string_view, int, bool>` или парой `enum + union`

Для ошибок парсинга и исполнения выкидывайте исключения. Вы можете сделать
несоклько _иерархий исключений_ подо все случаи жизни. В исключении указывайте
участок исходного кода, где произошла ошибка.

## Трудозатратность задания

You tell me

## Коммантарии

Потихоньку мы приближаемся к MVP нашего языка. В следующих сериях мы
постараемся построить таблицу символов. Выделить проверку типов в отдельный
_pass_ компилятора. Затем мы научимся генерировать код промежуточного
представления QBE.

## References 

1. Dragonbook — содержит лучший материал по парсингу.
2. [Simple but Powerful Pratt Parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html)
