
# 6-QBE-IR

`Компилятор = Фронтэнд + Бэкэнд`

Как невозможно составить сложную мысль без человеческого языка, так невозможно
составить сложную программу без абстракций, предоставляетмых языком
прогрммирования. Языки позволяют нам **лучше думать**. Как можно думать о том,
что нельзя сказать?

> Whereof one cannot speak, thereof one must be silent.

<img src="./media/5-wittgenstein.jpg" width="300" align="right">

**Фронтэнд** содержит все знания о природе и внешней структуре языка. Он
позволяет нам мыслить абстракциями, не сильно заботясь о железе.

```
Frontend:  Parse     ->
=========  Typecheck ->
           (Optimize, Rewrite, Lift Lambdas, etc) ->
           Generate IR.
```

**Задача бэкэнда** — это оптимизация программы и генерация инструкций
ассемблера под конкретню архитектуру. Бэкэнд не хочет знать о поверхностном
синтаксисе языка.

```
Backend:     Optimizer          ->
========     Register Allocator ->
             (Assembly          ->
             Linking)
```

Промежуточное представление — это форма программы, над которой работает бэкэнд.
Это также протокол сообщения между фронтэндом и бэкэндом.

## QBE IR

В языке Étude реализована кодогенерация в IR бэкэнда
[QBE](https://c9x.me/compile/).

Как и все современные бэкэнды, он использует SSA форму. Однако в тексте IR QBE
позволяет модифицировать региcтры, так что на практике мы можем писать очень
простой и компактный кодогенератор.

Простая функция, использующая это свойство, выглядит как-то так:

```
function w $loop() {
@start
        %x =w copy 100
        %s =w copy 0
@loop
        %s =w add %s, %x          <<<------ Modifying %s!
        %x =w sub %x, 1                <<<--- And %x
        jnz %x, @loop, @end
@end
        ret %s
}
```

### Обзор

Перед началом внимательно прочитайте документацю:
https://c9x.me/compile/doc/il-v1.1.html

Сейчас нам пригодится общая информация о синтаксисе:

- какие есть знаки (`$`, `%`, `@`)
- какие есть типы (`w`, `l`, `b`, `h`)
- какие есть **инструкции**
- как **определять функции**
- что значит *export*
- как **аллоцировать память** на стеке
- как **делать jump** по тегам
- как определять **блоки данных**

### Типы в IR

В данном IR целочисленные регистры имеют типы `w` или `l`. В то время как `b` и
`h` используюся для данных.

Я выделил следующие четыре ситуации, в которых требуется указвать тип в IR:
- *store*
- *load*
- *assignment* `=`
- *argument* (и определение , и вызов)

Составим табличку для нашего небольшого набора типов (*дозаполните её*!)  
Или *см. Appendix A.*

| Ситуация   | Int  | Pointer | Bool  | Char  | Unit
| ---------  | ---- | ------- | ----- | ----- | ----
| `store`    | `w`  |   `l`   |   ?   |   ?   |  No
| `load`     | `w`  |   `l`   |   ?   |   ?   |  No
| `=`        | `w`  |   `l`   |   ?   |   ?   |  No
| `argument` | `w`  |   `l`   |   ?   |   ?   |  No

**Advice.** Для всех этих ситуаций выделите функцию—хелпер, принимающую тип и
возвращающую нужный суффикс. `StoreSuf`, `LoadSuf`, etc.

#### Load: Sign Extension / Zero extension

В инструкции `load` есть два варианта:

```
%.1 =w loadub %byte     <<<----- дополнит байт до 4 байтов нулями
          ---

%.2 =w loadsb %byte     <<<----- дополнит нулями или единицами 
          ---                               в зависимости от знака
```

Посмотрите пример здесь: [Wiki: Sign Extension](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4#%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%BD%D0%B0%D0%BA%D0%B0)

Дополнительный код позволяет нам не думать о знаках, когда мы производим
операции над регистрами. Однако при загрузке необходимо осознавать, *что* мы
загружаем.

- знаковый байт (*signed byte*) $\Rightarrow$ `loadsb` (sign-extension)
- беззнаковый байт (*unsigned byte*) $\Rightarrow$ `loadub` (zero-extension)

#### Subtyping

Бэкэнд может выкинуть дополнительную информацию, например, `%w2 =w add %l %w` —
здесь верхние биты `%l` просто отбросятся.

Но бэкэнд не может взять информацию из ниоткуда: `%w` до `%l` можно дополнить либо
c `sign-extension`, либо c `zero-extension`.

### QbeValue

Как всегда мы будем рекусивно обходить AST, выписывая текст промежутчного
представления.

При этом у нас бывает несколько вариантов значений: глобальные, локальные,
константы. Мы хотим обращаться с ними единообразно.

Пусть `QbeValue = Temporary (%t) | Global ($data) | Const (4)` энкапсулирует
эту информацию.

**Вопрос**: подумайте, как это использовать.

## Задание

- *Пререквизит*: установите **QBE**
- Прочитайте **документацю** https://c9x.me/compile/doc/il-v1.1.html
- Попробуйте **составить** и **перевести** программу в IR *вручную*
- Научитесь `Emit`—ить определения функций (без тела)
- Реализуйте **вызов функций**, попробуйте вызвать `printf`
- Подумайте над преставлением `QbeValue`
- Реализуйте **аллокацию переменных** `var t = 5`
- Реализуйте **доступ к переменным** на чтение и на запись
- Реализуйте `+`, `-`, `*` и тд.

Посмотрите, как реализованы кодогенераторы в
[cproc: qbe.c](https://github.com/michaelforney/cproc/blob/master/qbe.c) и
[hare: gen.{h, c}](https://git.sr.ht/~sircmpwn/harec/tree/master/item/include/gen.h)

## Реализация

- Можете создать дополнительный класс, который поможет вам определять параметры
  разных объектов: `Measure`.

  В будущем там будет `Alignment`, `Size`, `FieldOffset`, и тд.

- Создайте счётчик, который будет выдавать бесконечную серию регистров: `%.1`
  `%.2` `%.3` и тд.

  Не экономьте их: больше регистров богу регистров

## Appendix A.

| Ситуация   | Int  | Pointer | Bool  | Char  | Unit
| ---------  | ---- | ------- | ----- | ----- | ----
| `store`    | `w`  |   `l`   |  `b`  |  `b`  |  No
| `load`     | `w`  |   `l`   |  `ub` |  `ub` |  No
| `=`        | `w`  |   `l`   |  `w ` |  `w`  |  No
| `argument` | `w`  |   `l`   |  `ub` |  `ub` |  No

