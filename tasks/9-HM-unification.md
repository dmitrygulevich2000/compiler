#  9. HM / Unification

Когда-то давно мы ввели **статическую систему типов**, чтобы минимизировать
вероятность ошибок (и иметь возможность укладывать данные).

Однако в текущем виде она требует от программистов **большого количества
аннотаций для компилятора**.  

> Это мы ещё легко отделались: *см.* [Rust Name Mangling Compression](https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html#compressionsubstitution)
> для примеров **по-настоящему** длинных имён.

В связи с этим современные языки программирования зачастую используют систему
**автоматического вывода типов** (*type inference*), которая уменьшает
потребность в ручных аннотациях.

***Original paper***: [Principal type-schemes for functional programs](https://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf)

Идейно её можно разделить на несколько частей:
1. **Юнификация** типов ← *сегодня*!
2. **Генерализация** типов
3. **Инстанцирование** шаблонов (или [другие методы](https://okmij.org/ftp/Computation/typeclass.html))
4. **Классы типов**

Начнём с механизма **юнификации типов**.

## Unification: *Intro*

**TLDR;** поддеживаем указатели на *самый конкретный тип* с помощью *DSU*.

> — Type inference is mostly a matter of finding out the obvious.  
> François Pottier, ведущий разработчик языка *OCaml*

- Пусть **целочисленный литерал** имеет тип $\tt{Int}$
- Пусть **бинарный оператор** $+$ работает c типами  $\tt{Int}$ и $\tt{Int}$

Рассмотрим **вопросы**:

 * Какой тип будет иметь функция `f1`?

   ```etude
      fun f1 x = x + 2;
   ```
* — функция `f2`?
   ```etude
      fun f2 p = *p + 1;
   ```
* — функция `f3`?
   ```etude
      fun f3 verbose message = if verbose then message
                        else "";
   ```

Заметим, что мы здесь мысленно сделали:
- **присвоили** каждому символу **неизвестный тип**,
- с помощью синтаксических правил **ограничили его**.

### Путь: *AST → Constraints → Substitution*

Алгоритм начинает с прохода по дереву и находжения всех *ограничений* на типы.
Пока что наш [*язык ограничений*](https://youtu.be/-TJGhGa04F8?t=1387) состоит
только из **равенств типов** (`~`).

Они решаются с помощью алгоритма ***юнификации***, давая нам ***подстановку***
(*substitution*), т.е. отображение из *неизвестной переменной  типа* (`$_`) в
конкретный тип.

Для поддержания текущей *подстановки* сопоставим каждой *переменной типа*
указатель на её ***лидера***. *Лидер* — это самый конкретный кандидат для
переменной.

#### Пример 1: Вектор

Пусть у нас в таблице символов есть следующие функции.

|  Function  |      Signature       |
| ---------- | -------------------- |
| `make_vec` |     `-> Vec(a)`      |
| `push`     | `*Vec(a) -> a -> ()` |

**Вопрос**: Какой тип у переменной `t`?

```
    var t = make_vec();
    push(&t, 5);
```

**Ответ**:

1) Первая строка генерирует **ограничение** `$1 ~ Vec($2)` — вектор из неизвестных переменных конкретнее, чем неизвестная переменная `$1`.
2) Вторая строка генерирует **ограничение** `$1 ~> Vec($2) ~ Vec(Int)` —
вектор из `Int` *конкретнее*, чем вектор из неизвестных переменных.

**Итого**, мы можем вывести, что переменная `t` **должна иметь тип** `Vec(Int)`.

### Форма типа

Что такое тип для нас? Это либо **переменная**, либо **конструктор типа** ([напоминание: поддерживаемые конструкторы](https://github.com/otakubeam/compilers-tasks/blob/master/tasks/5-static-types.md#%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD)).

| Type                  | [Representation](https://en.wikipedia.org/wiki/The_World_as_Will_and_Representation) | Example     |
| --------------------  | --------------------------------------------------------------- | -------------------------------  |
| ***Pointer*** `*`     | *underlying*: `*Type`                                           | `*$1`                            |
| ***Function*** `->`   | *args*: `[Type]` + *res*: `*Type`                               | `$1 -> Vec($1)`                  |
| ***Variable*** `$`    | *leader*: `*Type` + *id*: `Int`                                 | `$1`                             |
| ***Applicative***     | *name*: `Str` + *args*: `[Type]`                                | `Vec($1)`                        |
| ***Primitive***       | *tag:* `Int`, `Bool`, `Unit`, etc                               | `Int`, `Bool`, ...               |
| `struct`              | *fields*: `[Field]`                                             | `struct {  data: *$1 }`          |

### Алгоритм Юнификации

Нам нужна функция **Unify** с такой семантикой — для двух типов
- *рекурсивно сравнить их*,
- *подвесить переменные типа* к их соотвествующим лидерам.

#### Примеры

- $\tt{Unify(?0, ?1)}$
- $\tt{Unify(Int, ?1)}$
- $\tt{Unify(?2, \ \ Vec(?1))}$
- $\tt{Unify(HashMap(?1, Bool), HashMap(Int, ?3))}$

## Задание

- **Сотрите** свою предыдущую систему типов,
- **Приведите типы** к удобному для юнификации виду (`tag + union`),
- **Реализуйте функцию** `Unify`, решающую ограничение равенства,
- **Создайте класс** `Solver`,
  ответственный за решение проблемы *type inference* — из него вызываются все оставльные методы.
- **Создайте класс** `ConstraintGenerator`,
  отвественный за проход по AST и сбор ограничений на типы.
- При **возникновении ошибки**, откладывайте её для дальнейшей обработки.

## Связь с логическим программированием

**Prolog**, etc

## В следующих сериях

Мы узнаем, как можно представить себе функцию

```
fun id x = x;
```

## References

- *TAPL*, Chapter 22
- [Typing Haskell in Haskell](http://web.cecs.pdx.edu/~mpj/thih/thih.pdf) (later?)
- [Stackoverflow: Implementing Type Inference](https://stackoverflow.com/questions/415532/implementing-type-inference)
