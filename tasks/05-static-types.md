
# 5. Static Type Checking

Уже на этапе лексического и синтаксического анализа многие неправильные
программы будут отвергнуты. Например, то, что все присваивания имеют с левой
стороны *lvalue* — это чисто синтаксическое свойство.

Однако многие семантические требования не могут быть проверены исключительно с
тестирования принадлежности к какому-то контекстно-свободному языку.

До сих пор в нашем интерпретаторе мы проверяли возможность операции прямо перед
её исполнением. Для компилятора же ествественно хотеть иметь статичесике типы
(хотя бы для того, чтобы знать их размеры). Давайте вынесем эту проверку в
отдельный этап компиляции.

## Дизайн

Для начала постараемся разработать простую однонаправленную синтезирующую
систему типов, как в Си или С++.

В дизайн системы типов должны входить некоторое количество *фундаментальных
типов*,  а также конструкторы типов.


1. **Определение**

   **Конструктор типа** — это функция на уровне типов, принимающая несколько
   типов и возвращающая другой тип.

   Здесь типы обозначаются как \*

   Например,

   1. `Vec`, `Maybe` имеют сингнатуру `* -> *`.
   2. `HashMap` и `->` — `* -> * -> *`.
   3. Примитивные типы и типы, не содержащие ни одного параметра, яляются
      константами. `Int`, `IrcMessage`, `Vec(Int)` : `*`


Какие фундаментальные типы мы хотим иметь? Заведём новое правило.

```diff
+   <primitive-type> ::= Int | Bool | String | Char | Unit | () | !
```
Какие конструкторы хотим поддерживать? Пока что всё просто.

1. `->` — конструктор функции
2. `*` — конструктор указателя

```diff
+  <type-expression> ::= <constructor-type>
+                      | <constructor-type> -> <type-expression>
+
+  <constructor-type> ::=
+                       | * <constructor-type>
+                       | <primitive-type>
```


### Замечание про +

Во многих яызках оператор + является **перегруженным**: он может работать как
спарой`(Int, Int)`, так и с парой `(Double, Double)`. В системе Hindley-Milner,
на основе которой работает *Étude* это разрешается по-разному. Например, в
Haskell мы выражаем это с помощью классов типов и механизма 'defaulting'.

### Сингатуры функций и типы переменных

В грамматику деклараций языка необходимо встроить сигнатуры. Сделаем это так.
(`of` читается как "*of type*")

```diff
~
+ <signature> ::= of <type-expression>
~
~ <function-declaration> ::=
+                            <signature>
~                            fun <identifier> <parameter-list> = <expression> ;
~
~ <variable-declaration> ::=
+                            <signature>
~                            var <identifier> = <expression> ;
```

Как это выглядит:

```haskell
of *List(a) -> Maybe(a)
fun last_item list = ...;

-- In main
    of *List(Int)
    var list = ..........................;
```

## Curry-Howard Isomorphism

> Соответствие Карри — Ховарда (изоморфизм Карри — Ховарда, англ.
> formulæ-as-types interpretation) — наблюдаемая структурная эквивалентность
> между математическими доказательствами и программами, которая может быть
> формализована в виде изоморфизма между логическими системами и
> типизированными исчислениями.

[Вики: Соответствие Карри — Ховарда](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D1%80%D0%B8_%E2%80%94_%D0%A5%D0%BE%D0%B2%D0%B0%D1%80%D0%B4%D0%B0)

Как правило мы преслудуем цель доказать для данной конкретной системы типов,
что в правильно типизированных программах "ничто не может пойти не так"
(семантика отражена верно).

Для определения системы типов обычно используются **typing rules** — правила
типизирования. Рассмотрим их на примере простой формы лямбда исчисления.

## Typing Rules for Simply Typed Lambda Calculus

Пусть наш *терм* $e$ представляется как

$e ::= n∣x∣−e∣e + e∣ee∣λx:T.e$,

где
1. $n$ — целочисленный литерал
2. $x$ — идентификатор

$\Gamma$ — это **контекст исполнения программы** (таблица символов, содержащая
для каждого идентфикатора его тип).

Символ $:$ читается как "*имеет тип*".

Для определения правильности типов в нашей системе нам понадобится 6 правил.

1. Первые два правила позволяют нам строить суждения о литералах и
   идентификаторах.

$$
\begin{gather*}
\frac{n \in \mathbb{N}}{\Gamma \vdash n : \mathtt{Int}} \ (\mathtt{Literal}) \qquad
\frac{(x, T) \in \Gamma}{\Gamma \vdash x : T} \ (\mathtt{Lookup})  \qquad
\end{gather*}
$$

2. Далее идут правила для отрицания и сложения.

$$
\begin{gather*}
\frac{\Gamma \vdash e : \mathtt{Int}}
     {\Gamma \vdash \mathtt{-}e : \mathtt{Int}} \ (\mathtt{Neg}) \qquad
\frac{\Gamma \vdash e_1 : \mathtt{Int} \quad \Gamma \vdash e_2 : \mathtt{Int}}
     {\Gamma \vdash e_1\mathtt{+}e_2 : \mathtt{Int}} \ (\mathtt{Sum})
\end{gather*}
$$


3. Наконец, идут два зеркальных правила:

   - Первое правило называется `Abs` в  честь лябда-абстракции.

     Читаем так: если у нас есть выражение $e$, которое имеет тип $T_2$ в
     контексте, где идентификатор $x$ имеет тип $T_1$, то мы можем "навесить
     $\lambda$-квантор" и получить функцию с типом $T_1 \to T_2$.

   - Второе правило гласит, что при приминении функции к её аргументу получаем её результат.

$$
\frac{\Gamma,x :T_1 \vdash e : T_2 }{\Gamma \vdash (\lambda x{:}T_1. e) : (T_1 \to T_2)} \ (\mathtt{Abs}) \qquad
\frac{\Gamma \vdash e_1 : T \to T' \quad \Gamma \vdash e_2 : T}
     {\Gamma \vdash e_1 \, e_2 : T'} \ (\mathtt{App})
$$


Аналогично можно придумывать и другие правила, например про `IF` и тд.

Для интересующихся системами типов классической книгой и учебинком является
**Types and Programming Languages** by
[Benjamin C.Pierce](http://www.cis.upenn.edu/~bcpierce) (*TAPL*)

## Задание

- Придумайте, как **представлять типы** в программе.

  Подсказки:
  - см. **Chibicc, Harec, Cproc** и тд
  - [A Regargetable C Compiler](https://drh.github.io/lcc/) — *lcc book*

- Научитесь **сравнивать типы**
- Создайте **визитора**,  **проверяющего типы** выражений.

  Проверка типов таким образом похожа на интерпретацию, только вместо объектов
  интерпретатора мы работаем с типами, заходим в обе ветки `if`, не
  зацикливаемся и тд.

  **Typing Rules** — это те действия, которые визитор совершает при проверке
  какой-то вершины дерева.

- Выделите классы ошибок, возникающих в результате проверки типов.

  При несоответствии типов выкидывайте исключения. *См*.
  [Etude/Old: TypeError.hpp](https://github.com/otakubeam/etude/blob/0.1.0/src/types/check/type_error.hpp)

## Реализация

Не заносите размер типа в структуру типа: у нас может быть много бэкэндов с
разными представлениями данных.

Интерпретатор теперь можно удалить, он нам больше не нужен.

## Дополнительные материалы

- *Dragon Book*: Chapter 6.1
- *TAPL*: Chapter 9
- [rustc-guide: type](https://rustc-dev-guide.rust-lang.org/ty.html)

Fun with dependent types:
- Type Theory for the Working Rustacean - Dan Pittman
- Idris, Coc, Agda


