
# 10. HM / Generalization

## Мотивация

Хотим написать реализацию контейнера `Vec`:

```etude
    type Vec a = struct {
        data: *a,
        size: Int,
        capacity: Int,
    };
```

Также хотим иметь функции:

```
    of *Vec(a) -> a -> ()
    fun append vector value;
```

```
    of Int -> *Vec(a)
    fun make_vec intial_size;
```

## Polymorphic $\tt{ id }$

Рассмотрим самую простую полиморфную функцию — `id`:

```etude
    fun id x = x;
```

У неё есть единственное ограничение:
- тип **аргумента** `x` должен быть равен типу **возвращаемого значения** `x`.

$$\tt{x :: a} \Rightarrow id :: a \rightarrow a$$

Но что такое `a`?

- Это  **неизвестный уникальный тип**,
- Он **не был ограничен** никаким конкретным типом.

Следовательно, мы **можем его обобщить**:

$$\tt{id :: \forall a \ \ a \rightarrow a}$$

## Обобщение `$1` ⇒ `G1`

### Алгоритм вывода типов (обзорно)

1. **Сгенерировать** *ограничения*,
2. **Решить** ограничения *юнификацией*,

    <kbd>
    <img src="https://raw.githubusercontent.com/otakubeam/etude-course-media/master/type_store.png" width="600">
    </kbd>

3. **Обобщить** *свободные переменные типа*.
 
    ```
                      Generalize(id.type) =
                    -------------------------

                            = Gen(A -> B)
                          ------------------

                            Gen(A)  +  Gen(B)
                        -----------   ----------

                            Gen($1) +  Gen($1)
                          ---------   ---------

                               G1   +    G1
                              ----      ----
    ```

## Вызов полиморфной функции

[***Матлог:*** Лемма о свежих константах!](https://wiki.compscicenter.ru/images/a/a0/Mlc09_2018.pdf)


Пусть дана следующая программа

```
# main.et

fun id x = x;    # <<---- (0) forall a. a -> a

fun main argc arvg = {

    id(true);    # <<---- (1) Bool -> Bool

    id(0)        # <<---- (2) Int -> Int
};
```

Мы уже выяснили, что правильный тип для функции `id` — это $\forall a \ \ a → a$. 

- В $(1)$ случае нужно вызвать её с настоящим типом $\tt{ Bool → Bool }$,
- Во $(2)$ случае нужно вызвать её с настоящим типом $\tt{ Int → Int }$.

Для этого мы **возьмём сигнатуру функции** ($\forall a \ \ a → a$) и **заменим
все  параметры** ( $a$ ) под квантором всеобщности  на *свежие переменные типа*
(`$n+1`). Затем объединим их с типами агрументов и продолжим исполнение как
обычно. 

**Вопросы**: 

- Влияет ли *порядок обработки*? — Да, влияет.
- Rust: *Object Safety*

## Компоненты сильной связанности

Вы могли заметить, что для *"освежения"* полиморфных функций нам необходимо
иметь знать их обобщённый тип. Кроме того, если обрабатывать функции в
неправильном порядке, то их полиморфизм будет ограничен.  

#### Пример: ограниченный полиморфизм $id$

```
fun main = {
    id(0)      # <<---- id :: Int -> Int ?
};

fun id x = x;  # Yes, id :: Int -> Int! Ok!
```

Чтобы преодолеть это ограничение, нужно отсортировать функции по их
зависимостям.

#### План построения оптимального порядка обхода функций

- Составить **граф вызовов** функций в программе,
- Найти в нём **компоненты сильной связности**,
- Отсортировать их **топологически**.

<p align="center">
<kbd>
<img src="https://raw.githubusercontent.com/otakubeam/etude-course-media/master/top_sort.webp" width="600">
</kbd>
</p>

***Note***: Второй пункт необходим, так как функции могут [вызывать друг друга](https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F).

После построения плана, мы просто проводим алгоритм юнификации и обобщения не
для одной функции, а для группы.

### Рекурсивные функции

Рекурсивная функция — это что-то похожее, только проще. Её определение зависит
от неё же самой. При вызове нужно просто юнифицировать её тип с типами
вызываемых аргументов.

#### Полиморфная рекурсия

**TODO:** интересно знать, что она существует. Требует аннотаций.

#### Расходящиеся функции

**Q:** Какая сигнатура будет у следующей функции?

```etude
    fun undefined = undefined();
```

**Q:** Почему это работает?

```
    of Maybe(a) -> a
    fun unwrap maybe = match maybe {
        | .some a: a
        | .none: undefined()
        };
```

## Инстанцирование 

Инстанцирование начинается из функции `main` и последовательно "заражает" все
функции, которые встечаются на его пути.

Нам требуется переписать дерево.


## Изменения в грамматке


## Задание
